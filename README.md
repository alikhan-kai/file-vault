Реактивное приложение для асинхронной загрузки файлов в S3-хранилище с механизмом дедупликации. Проект разработан на базе Java 21 и Spring Boot 3.5.10.
Технологический стек
Java 21: Использование современных функций языка и виртуальных потоков.
Spring WebFlux: Полностью неблокирующая обработка запросов.
MinIO (v8.5.7): Объектное хранилище (S3 API).
PostgreSQL: Хранение метаданных через реактивный драйвер R2DBC.
Flyway: Автоматическое управление миграциями базы данных.
Redis: Кэширование хэш-сумм для обеспечения идемпотентности.
Lombok: Минимизация шаблонного кода.

Инструкция по запуску
Запустите Docker Desktop.
В корне проекта выполните команду: docker-compose up -d.
Запустите приложение через IDE или команду ./mvnw spring-boot:run.
При старте система автоматически инициализирует схему в PostgreSQL через Flyway и создаст бакет uploads в MinIO.
Сервис доступен по адресу: http://localhost:8080.

Тестирование и проверка
1. Загрузка файла (Postman)
Метод: POST
URL: http://localhost:8080/api/files/upload
Body: form-data, ключ file (выбрать любой файл).
Результат: Статус 202 Accepted и уникальный SHA-256 хэш.

2. Проверка идемпотентности
При повторной отправке того же файла система через Redis определит существующий хэш и вернет уведомление о том, что файл уже обрабатывается или существует, не нагружая хранилище повторной записью.

3. Получение статуса и метаданных
Метод: GET
Пример ссылки: http://localhost:8080/api/files/status/f8f5e3c943ec0f81cc08ccf795000623bbb2ba7de5cf4b20ffa8cb18f5443220
Результат: JSON с полной информацией: имя файла, размер, статус (COMPLETED) и путь в хранилище.

4. Панель управления MinIO (Визуальная проверка)
URL: http://localhost:9001
Логин: minioadmin
Пароль: minioadmin
После загрузки файла через Postman, вы можете зайти в раздел Buckets -> uploads и увидеть сохраненный объект

Внутренняя логика
Приложение реализует паттерн асинхронной обработки. После получения FilePart контроллер мгновенно подтверждает прием запроса. Основная логика (вычисление SHA-256, загрузка байтов в MinIO и сохранение метаданных) выполняется в неблокирующем пуле потоков boundedElastic. Использование Redis как распределенного замка на основе хэша файла гарантирует, что система защищена от дубликатов даже при высокой интенсивности запросов.
